---
phase: 16-sidecar-display
plan: 01
type: execute
---

<objective>
Display ASCII sidecar alongside rendered Mermaid diagrams in AI chat responses with view toggle.

Purpose: Users can switch between rendered diagram and ASCII sidecar for accessibility/fallback
Output: DiagramBlockRenderer component + MessageContent component integrated into ChatMessage
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-sidecar-detection/15-01-SUMMARY.md

**Source files:**
@src/components/chat/ChatMessage.vue
@src/components/chat/MarkdownRenderer.vue
@src/composables/useMermaid.ts
@src/utils/diagramParser.ts
@src/types/chat.ts

**Tech stack available:**
- TypeScript 5.9.3
- Vue 3.5.26
- Mermaid.js (already used in app)

**Established patterns:**
- Components use `<script setup lang="ts">`
- CSS variables for theming
- useMermaid composable for rendering diagrams

**Constraining decisions:**
- Phase 15: DiagramBlock type and parseDiagramBlocks() utility exist
- Mermaid+sidecar are adjacent in AI response
- Sidecar may be absent (mermaid block alone is valid)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create DiagramBlockRenderer component</name>
  <files>src/components/chat/DiagramBlockRenderer.vue</files>
  <action>
Create a component that renders a single DiagramBlock with view toggle:

```vue
<script setup lang="ts">
import { ref, onMounted, watch } from 'vue'
import type { DiagramBlock } from '@/types'
import { useMermaid } from '@/composables/useMermaid'

const props = defineProps<{
  block: DiagramBlock
}>()

type ViewMode = 'diagram' | 'ascii' | 'code'

const viewMode = ref<ViewMode>('diagram')
const diagramId = ref(`diagram-${props.block.id}-${Date.now()}`)
const { render, error, isRendering } = useMermaid()

async function renderDiagram() {
  if (viewMode.value === 'diagram') {
    await render(diagramId.value, props.block.mermaidContent)
  }
}

onMounted(renderDiagram)
watch(viewMode, renderDiagram)
</script>

<template>
  <div class="diagram-block">
    <div class="diagram-tabs">
      <button
        class="tab-btn"
        :class="{ active: viewMode === 'diagram' }"
        @click="viewMode = 'diagram'"
      >
        Diagram
      </button>
      <button
        v-if="block.sidecar"
        class="tab-btn"
        :class="{ active: viewMode === 'ascii' }"
        @click="viewMode = 'ascii'"
      >
        ASCII
      </button>
      <button
        class="tab-btn"
        :class="{ active: viewMode === 'code' }"
        @click="viewMode = 'code'"
      >
        Code
      </button>
    </div>

    <div class="diagram-content">
      <!-- Rendered diagram -->
      <div
        v-show="viewMode === 'diagram'"
        :id="diagramId"
        class="mermaid-container"
      ></div>

      <!-- Loading state -->
      <div v-if="viewMode === 'diagram' && isRendering" class="diagram-loading">
        Rendering...
      </div>

      <!-- Error state - show ASCII fallback if available -->
      <div v-if="viewMode === 'diagram' && error" class="diagram-error">
        <div class="error-message">{{ error.message }}</div>
        <pre v-if="block.sidecar" class="ascii-fallback">{{ block.sidecar.content }}</pre>
      </div>

      <!-- ASCII sidecar -->
      <pre v-show="viewMode === 'ascii'" class="ascii-content">{{ block.sidecar?.content }}</pre>

      <!-- Raw mermaid code -->
      <pre v-show="viewMode === 'code'" class="code-content">{{ block.mermaidContent }}</pre>
    </div>
  </div>
</template>

<style scoped>
.diagram-block {
  margin: var(--spacing-sm) 0;
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius-md);
  overflow: hidden;
}

.diagram-tabs {
  display: flex;
  gap: 1px;
  background: var(--color-border);
  border-bottom: 1px solid var(--color-border);
}

.tab-btn {
  flex: 1;
  padding: var(--spacing-xs) var(--spacing-sm);
  background: var(--color-surface);
  border: none;
  color: var(--color-text-secondary);
  font-size: var(--font-size-xs);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.tab-btn:hover {
  background: var(--color-surface-elevated);
  color: var(--color-text-primary);
}

.tab-btn.active {
  background: var(--color-surface-elevated);
  color: var(--color-primary);
  font-weight: var(--font-weight-medium);
}

.diagram-content {
  padding: var(--spacing-sm);
  background: var(--color-surface-elevated);
  min-height: 60px;
}

.mermaid-container {
  display: flex;
  justify-content: center;
  overflow-x: auto;
}

.mermaid-container :deep(svg) {
  max-width: 100%;
  height: auto;
}

.diagram-loading {
  text-align: center;
  color: var(--color-text-secondary);
  font-size: var(--font-size-sm);
  padding: var(--spacing-md);
}

.diagram-error {
  color: var(--color-error);
}

.error-message {
  font-size: var(--font-size-sm);
  margin-bottom: var(--spacing-sm);
}

.ascii-fallback,
.ascii-content,
.code-content {
  margin: 0;
  font-family: var(--font-mono, 'Fira Code', 'Consolas', monospace);
  font-size: 0.8em;
  line-height: 1.4;
  white-space: pre;
  overflow-x: auto;
  color: var(--color-text-primary);
}
</style>
```

Key features:
- Three view modes: diagram (rendered), ascii (sidecar), code (raw mermaid)
- ASCII tab only shown when sidecar exists
- Error state shows ASCII fallback if available
- Uses existing useMermaid composable
  </action>
  <verify>npm run type-check passes</verify>
  <done>DiagramBlockRenderer component created with view toggle</done>
</task>

<task type="auto">
  <name>Task 2: Create MessageContent component</name>
  <files>src/components/chat/MessageContent.vue</files>
  <action>
Create a component that parses AI response and renders text + diagram blocks:

```vue
<script setup lang="ts">
import { computed } from 'vue'
import type { DiagramBlock } from '@/types'
import { parseDiagramBlocks } from '@/utils/diagramParser'
import MarkdownRenderer from './MarkdownRenderer.vue'
import DiagramBlockRenderer from './DiagramBlockRenderer.vue'

const props = defineProps<{
  content: string
}>()

interface ContentSegment {
  type: 'text' | 'diagram'
  content?: string
  block?: DiagramBlock
}

const segments = computed<ContentSegment[]>(() => {
  const blocks = parseDiagramBlocks(props.content)

  if (blocks.length === 0) {
    return [{ type: 'text', content: props.content }]
  }

  const result: ContentSegment[] = []
  let lastIndex = 0

  for (const block of blocks) {
    // Text before this diagram block
    if (block.startIndex > lastIndex) {
      const textContent = props.content.slice(lastIndex, block.startIndex).trim()
      if (textContent) {
        result.push({ type: 'text', content: textContent })
      }
    }

    // The diagram block itself
    result.push({ type: 'diagram', block })
    lastIndex = block.endIndex
  }

  // Text after last diagram block
  if (lastIndex < props.content.length) {
    const textContent = props.content.slice(lastIndex).trim()
    if (textContent) {
      result.push({ type: 'text', content: textContent })
    }
  }

  return result
})
</script>

<template>
  <div class="message-content-parsed">
    <template v-for="(segment, index) in segments" :key="index">
      <MarkdownRenderer
        v-if="segment.type === 'text'"
        :content="segment.content!"
      />
      <DiagramBlockRenderer
        v-else-if="segment.type === 'diagram'"
        :block="segment.block!"
      />
    </template>
  </div>
</template>

<style scoped>
.message-content-parsed {
  line-height: 1.6;
}
</style>
```

This component:
- Parses content for diagram blocks using Phase 15's parser
- Splits content into segments (text before/between/after diagrams)
- Renders text segments with MarkdownRenderer
- Renders diagram blocks with DiagramBlockRenderer
  </action>
  <verify>npm run type-check passes</verify>
  <done>MessageContent component created to handle mixed content</done>
</task>

<task type="auto">
  <name>Task 3: Update ChatMessage to use MessageContent</name>
  <files>src/components/chat/ChatMessage.vue</files>
  <action>
Replace MarkdownRenderer with MessageContent for assistant messages:

1. Update import:
```typescript
import MessageContent from './MessageContent.vue'
```

2. Replace the template section:
```vue
<div class="message-content">
  <MessageContent v-if="message.role === 'assistant'" :content="message.content" />
  <template v-else>{{ message.content }}</template>
</div>
```

Remove the MarkdownRenderer import since MessageContent now handles it.
  </action>
  <verify>npm run type-check passes</verify>
  <done>ChatMessage updated to use MessageContent for AI responses</done>
</task>

<task type="auto">
  <name>Task 4: Verify build and test</name>
  <files>None</files>
  <action>
Run full verification:
1. npm run type-check
2. npm run build

Both must pass successfully.
  </action>
  <verify>npm run type-check && npm run build succeeds</verify>
  <done>Type check and build pass</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run type-check` passes
- [ ] `npm run build` succeeds
- [ ] DiagramBlockRenderer component renders mermaid diagrams
- [ ] DiagramBlockRenderer shows toggle for ASCII/Code views
- [ ] MessageContent correctly splits content into segments
- [ ] ChatMessage uses MessageContent for assistant messages
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors introduced
- Mermaid diagrams render in chat with view toggle
- ASCII sidecar accessible via toggle
- Phase 16 complete
</success_criteria>

<output>
After completion, create `.planning/phases/16-sidecar-display/16-01-SUMMARY.md`
</output>
